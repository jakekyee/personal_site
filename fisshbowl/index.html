<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fisshbowlüêü </title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="styles.css">
  <style>
   
  </style>
  <div class="crt"></div>
</head>
<body>

  
  <div id="app">
    <div class="container">
      <header>
        <h1>üêüfisshbowlüêü - ssh attempt analytics </h1>
        <p>Real-time monitoring of authentication attempts</p>
      </header>

      <!-- Loading State -->
      <div v-if="loading" class="loading">
        <div class="loading-spinner"></div>
        <p>Loading data...</p>
      </div>

      <!-- Error State -->
      <div v-else-if="error" class="error">
        <p>{{ error }}</p>
      </div>

      <!-- Dashboard Content -->
      <template v-else>
        <!-- Stats Cards -->
        <div class="stats-grid">
          <div class="stat-card">
            <div class="value">{{ totalAttempts }}</div>
            <div class="label">Total Attempts</div>
          </div>
          <div class="stat-card">
            <div class="value">{{ last24Hours }}</div>
            <div class="label">Last 24 Hours</div>
          </div>
          <div class="stat-card">
            <div class="value">{{ uniqueIPs }}</div>
            <div class="label">Unique IPs</div>
          </div>
          <div class="stat-card">
            <div class="value">{{ uniqueUsernames }}</div>
            <div class="label">Unique Usernames</div>
          </div>
        </div>

        <!-- Filters -->
        <div class="filters">
          <h3>Filters</h3>
          <div class="filter-grid">
            <div class="filter-group">
              <label>Search IP</label>
              <input type="text" v-model="filters.ip" placeholder="e.g. 192.168.0.1">
            </div>
            <div class="filter-group">
              <label>Search Username</label>
              <input type="text" v-model="filters.username" placeholder="e.g. admin">
            </div>
            <div class="filter-group">
              <label>Search Password</label>
              <input type="text" v-model="filters.password" placeholder="e.g. root">
            </div>
            <div class="filter-group">
              <label>Search Notes</label>
              <input type="text" v-model="filters.notes" placeholder="e.g. suspicious">
            </div>
            <div class="filter-group">
              <label>Time Range</label>
              <select v-model="filters.timeRange">
                <option value="all">All Time</option>
                <option value="1h">Last Hour</option>
                <option value="24h">Last 24 Hours</option>
                <option value="7d">Last 7 Days</option>
                <option value="30d">Last 30 Days</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Top Row: Timeline + Frequency Tables -->
        <div class="top-row">
          <!-- Timeline Chart -->
          <div class="timeline-card">
            <h3>Attempts Over Time</h3>
            <div class="timeline-controls">
              <button :class="{ active: timelineGroup === 'hour' }" @click="timelineGroup = 'hour'">Hourly</button>
              <button :class="{ active: timelineGroup === 'day' }" @click="timelineGroup = 'day'">Daily</button>
              <button :class="{ active: timelineGroup === 'week' }" @click="timelineGroup = 'week'">Weekly</button>
              <button :class="{ active: timelineGroup === 'month' }" @click="timelineGroup = 'month'">Monthly</button>
            </div>
            <div class="timeline-container">
              <canvas ref="timelineChart"></canvas>
            </div>
          </div>

          <!-- Username Frequency -->
          <div class="table-container compact">
            <div class="table-header">
              <h3>Username Frequency</h3>
              <span class="count">{{ usernameCounts.length }} unique</span>
            </div>
            <table>
              <thead>
                <tr>
                  <th class="sortable"
                      :class="{ asc: usernameSortColumn === 'username' && usernameSortDirection === 'asc', desc: usernameSortColumn === 'username' && usernameSortDirection === 'desc' }"
                      @click="toggleUsernameSort('username')">
                    Username
                  </th>
                  <th class="sortable"
                      :class="{ asc: usernameSortColumn === 'count' && usernameSortDirection === 'asc', desc: usernameSortColumn === 'count' && usernameSortDirection === 'desc' }"
                      @click="toggleUsernameSort('count')">
                    Count
                  </th>
                  <th class="sortable"
                      :class="{ asc: usernameSortColumn === 'percentage' && usernameSortDirection === 'asc', desc: usernameSortColumn === 'percentage' && usernameSortDirection === 'desc' }"
                      @click="toggleUsernameSort('percentage')">
                    %
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="item in paginatedUsernameCounts" :key="item.username">
                  <td><span class="credential">{{ item.username }}</span></td>
                  <td>{{ item.count }}</td>
                  <td>{{ item.percentage }}%</td>
                </tr>
              </tbody>
            </table>
            <div class="pagination">
              <button @click="usernamePage--" :disabled="usernamePage === 1">Prev</button>
              <span>{{ usernamePage }}/{{ usernameTotalPages }}</span>
              <button @click="usernamePage++" :disabled="usernamePage >= usernameTotalPages">Next</button>
            </div>
          </div>

          <!-- Password Frequency -->
          <div class="table-container compact">
            <div class="table-header">
              <h3>Password Frequency</h3>
              <span class="count">{{ passwordCounts.length }} unique</span>
            </div>
            <table>
              <thead>
                <tr>
                  <th class="sortable"
                      :class="{ asc: passwordSortColumn === 'password' && passwordSortDirection === 'asc', desc: passwordSortColumn === 'password' && passwordSortDirection === 'desc' }"
                      @click="togglePasswordSort('password')">
                    Password
                  </th>
                  <th class="sortable"
                      :class="{ asc: passwordSortColumn === 'count' && passwordSortDirection === 'asc', desc: passwordSortColumn === 'count' && passwordSortDirection === 'desc' }"
                      @click="togglePasswordSort('count')">
                    Count
                  </th>
                  <th class="sortable"
                      :class="{ asc: passwordSortColumn === 'percentage' && passwordSortDirection === 'asc', desc: passwordSortColumn === 'percentage' && passwordSortDirection === 'desc' }"
                      @click="togglePasswordSort('percentage')">
                    %
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="item in paginatedPasswordCounts" :key="item.password">
                  <td><span class="credential">{{ item.password }}</span></td>
                  <td>{{ item.count }}</td>
                  <td>{{ item.percentage }}%</td>
                </tr>
              </tbody>
            </table>
            <div class="pagination">
              <button @click="passwordPage--" :disabled="passwordPage === 1">Prev</button>
              <span>{{ passwordPage }}/{{ passwordTotalPages }}</span>
              <button @click="passwordPage++" :disabled="passwordPage >= passwordTotalPages">Next</button>
            </div>
          </div>
        </div>

        <!-- Charts -->
        <div class="charts-grid">
          <div class="chart-card">
            <h3>Top Usernames</h3>
            <div class="chart-container">
              <canvas ref="usernameChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>Top Passwords</h3>
            <div class="chart-container">
              <canvas ref="passwordChart"></canvas>
            </div>
          </div>
          <div class="chart-card">
            <h3>Top Username:Password Combos</h3>
            <div class="chart-container">
              <canvas ref="comboChart"></canvas>
            </div>
          </div>
        </div>

        <!-- Data Table -->
        <div class="table-container" style="margin-top: 12px;">
          <div class="table-header">
            <h3>Attempts Data</h3>
            <span class="count">Showing {{ paginatedData.length }} of {{ tableData.length }} entries</span>
          </div>

          <!-- Add Exclusion Inputs -->
          <div class="table-controls add-exclusion-row">
            <h4>Add Exclusion</h4>
            <div class="add-exclusion-input">
              <label>User:</label>
              <input type="text" v-model="newExclusion.username" placeholder="add..." @keyup.enter="addExclusion('username')">
            </div>
            <div class="add-exclusion-input">
              <label>Pass:</label>
              <input type="text" v-model="newExclusion.password" placeholder="add..." @keyup.enter="addExclusion('password')">
            </div>
            <div class="add-exclusion-input">
              <label>IP:</label>
              <input type="text" v-model="newExclusion.ip" placeholder="add..." @keyup.enter="addExclusion('ip')">
            </div>
          </div>

          <!-- Exclusion Controls -->
          <div class="table-controls">
            <h4>Exclude from Results</h4>

            <!-- Unified exclusion items (suggestions + custom) -->
            <div class="exclusion-item"
                 v-for="(item, index) in exclusionItems"
                 :key="'item-'+index"
                 :class="{ active: item.active }"
                 @click="toggleExclusion(item)">
              <span class="exc-checkbox"></span>
              <span class="exc-type">{{ item.type }}:</span>
              <span class="exc-value">{{ item.value }}</span>
              <span class="exc-count" v-if="item.count">({{ item.count }})</span>
              <button class="exc-remove"
                      v-if="item.isCustom"
                      @click.stop="removeExclusion(item.type, item.value)">&times;</button>
            </div>
          </div>

          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th class="sortable"
                    :class="{ asc: sortColumn === 'ip' && sortDirection === 'asc', desc: sortColumn === 'ip' && sortDirection === 'desc' }"
                    @click="toggleSort('ip')">
                  IP Address
                </th>
                <th class="sortable"
                    :class="{ asc: sortColumn === 'username' && sortDirection === 'asc', desc: sortColumn === 'username' && sortDirection === 'desc' }"
                    @click="toggleSort('username')">
                  Username
                </th>
                <th class="sortable"
                    :class="{ asc: sortColumn === 'password' && sortDirection === 'asc', desc: sortColumn === 'password' && sortDirection === 'desc' }"
                    @click="toggleSort('password')">
                  Password
                </th>
                <th class="sortable"
                    :class="{ asc: sortColumn === 'created_at' && sortDirection === 'asc', desc: sortColumn === 'created_at' && sortDirection === 'desc' }"
                    @click="toggleSort('created_at')">
                  Timestamp
                </th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="attempt in paginatedData" :key="attempt.id">
                <td>{{ attempt.id }}</td>
                <td><span class="ip-badge">{{ attempt.ip }}</span></td>
                <td><span class="credential">{{ attempt.username }}</span></td>
                <td><span class="credential">{{ attempt.password }}</span></td>
                <td>{{ formatDate(attempt.created_at) }}</td>
              </tr>
            </tbody>
          </table>
          <div class="pagination">
            <button @click="currentPage--" :disabled="currentPage === 1">Previous</button>
            <span>Page {{ currentPage }} of {{ totalPages }}</span>
            <button @click="currentPage++" :disabled="currentPage >= totalPages">Next</button>
          </div>
        </div>
      </template>
    </div>
  </div>

  <script>
    const { createApp, ref, computed, watch, onMounted, nextTick } = Vue;

    createApp({
      setup() {
        const attempts = ref([]);
        const loading = ref(true);
        const error = ref(null);
        const currentPage = ref(1);
        const perPage = 20;
        const frequencyPerPage = 15;

        const filters = ref({
          ip: '',
          username: '',
          password: '',
          notes: '',
          timeRange: 'all'
        });

        const timelineGroup = ref('hour');

        // Sorting for main table
        const sortColumn = ref('created_at');
        const sortDirection = ref('desc');

        // Sorting for password counts table
        const passwordSortColumn = ref('count');
        const passwordSortDirection = ref('desc');
        const passwordPage = ref(1);

        // Sorting for username counts table
        const usernameSortColumn = ref('count');
        const usernameSortDirection = ref('desc');
        const usernamePage = ref(1);

        // Custom exclusions
        const customExclusions = ref({
          username: [],
          password: [],
          ip: []
        });

        const newExclusion = ref({
          username: '',
          password: '',
          ip: ''
        });

        // Chart refs
        const usernameChart = ref(null);
        const passwordChart = ref(null);
        const comboChart = ref(null);
        const timelineChart = ref(null);

        // Chart instances
        let usernameChartInstance = null;
        let passwordChartInstance = null;
        let comboChartInstance = null;
        let timelineChartInstance = null;

        const API_URL = 'https://api.jakeyee.com/attempts?from=2024-01-01T00%3A00%3A00Z&to=2027-01-31T23%3A59%3A59Z';

        // Fetch data
        async function fetchData() {
          try {
            loading.value = true;
            const response = await fetch(API_URL);
            if (!response.ok) throw new Error('Failed to fetch data');
            const json = await response.json();
            console.log('API Response:', json); // Debug log
            // Handle both array and wrapped object responses
            if (Array.isArray(json)) {
              attempts.value = json;
            } else if (json && typeof json === 'object') {
              // Try common wrapper keys
              const data = json.data || json.attempts || json.results || json.items;
              attempts.value = Array.isArray(data) ? data : [];
              console.log('Extracted data:', attempts.value);
            } else {
              attempts.value = [];
            }
            // Sort by most recent first
            attempts.value.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
          } catch (e) {
            error.value = e.message;
          } finally {
            loading.value = false;
          }
        }

        // Filtered data
        const filteredData = computed(() => {
          let data = [...attempts.value];

          // Time filter
          if (filters.value.timeRange !== 'all') {
            const now = new Date();
            let cutoff;
            switch (filters.value.timeRange) {
              case '1h': cutoff = new Date(now - 60 * 60 * 1000); break;
              case '24h': cutoff = new Date(now - 24 * 60 * 60 * 1000); break;
              case '7d': cutoff = new Date(now - 7 * 24 * 60 * 60 * 1000); break;
              case '30d': cutoff = new Date(now - 30 * 24 * 60 * 60 * 1000); break;
            }
            data = data.filter(a => new Date(a.created_at) >= cutoff);
          }

          // Text filters
          if (filters.value.ip) {
            data = data.filter(a => a.ip.includes(filters.value.ip));
          }
          if (filters.value.username) {
            data = data.filter(a => a.username.toLowerCase().includes(filters.value.username.toLowerCase()));
          }
          if (filters.value.password) {
            data = data.filter(a => a.password.toLowerCase().includes(filters.value.password.toLowerCase()));
          }
          if (filters.value.notes) {
            data = data.filter(a => a.notes && a.notes.toLowerCase().includes(filters.value.notes.toLowerCase()));
          }

          return data;
        });

        // Find top outliers from filtered data
        const topUsername = computed(() => {
          const map = new Map();
          filteredData.value.forEach(a => map.set(a.username, (map.get(a.username) || 0) + 1));
          const sorted = [...map.entries()].sort((a, b) => b[1] - a[1]);
          return sorted.length > 0 ? { value: sorted[0][0], count: sorted[0][1] } : null;
        });

        const topPassword = computed(() => {
          const map = new Map();
          filteredData.value.forEach(a => map.set(a.password, (map.get(a.password) || 0) + 1));
          const sorted = [...map.entries()].sort((a, b) => b[1] - a[1]);
          return sorted.length > 0 ? { value: sorted[0][0], count: sorted[0][1] } : null;
        });

        const topIP = computed(() => {
          const map = new Map();
          filteredData.value.forEach(a => map.set(a.ip, (map.get(a.ip) || 0) + 1));
          const sorted = [...map.entries()].sort((a, b) => b[1] - a[1]);
          return sorted.length > 0 ? { value: sorted[0][0], count: sorted[0][1] } : null;
        });

        // Table data with exclusions and sorting
        const tableData = computed(() => {
          let data = [...filteredData.value];

          // Exclude custom values
          if (customExclusions.value.username.length > 0) {
            data = data.filter(a => !customExclusions.value.username.includes(a.username));
          }
          if (customExclusions.value.password.length > 0) {
            data = data.filter(a => !customExclusions.value.password.includes(a.password));
          }
          if (customExclusions.value.ip.length > 0) {
            data = data.filter(a => !customExclusions.value.ip.includes(a.ip));
          }

          // Sort
          data.sort((a, b) => {
            let valA = a[sortColumn.value];
            let valB = b[sortColumn.value];

            // Handle date sorting
            if (sortColumn.value === 'created_at') {
              valA = new Date(valA).getTime();
              valB = new Date(valB).getTime();
            } else {
              // String comparison (case-insensitive)
              valA = String(valA).toLowerCase();
              valB = String(valB).toLowerCase();
            }

            if (valA < valB) return sortDirection.value === 'asc' ? -1 : 1;
            if (valA > valB) return sortDirection.value === 'asc' ? 1 : -1;
            return 0;
          });

          return data;
        });

        // Toggle sort
        function toggleSort(column) {
          if (sortColumn.value === column) {
            sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
          } else {
            sortColumn.value = column;
            sortDirection.value = 'asc';
          }
          currentPage.value = 1;
        }

        // Add custom exclusion
        function addExclusion(type) {
          const value = newExclusion.value[type].trim();
          if (value && !customExclusions.value[type].includes(value)) {
            customExclusions.value[type].push(value);
            newExclusion.value[type] = '';
          }
        }

        // Remove custom exclusion
        function removeExclusion(type, value) {
          const index = customExclusions.value[type].indexOf(value);
          if (index > -1) {
            customExclusions.value[type].splice(index, 1);
          }
        }

        // All exclusions as flat array for display
        const allExclusions = computed(() => {
          const result = [];
          for (const type of ['username', 'password', 'ip']) {
            for (const value of customExclusions.value[type]) {
              result.push({ type, value });
            }
          }
          return result;
        });

        // Unified exclusion items - combines suggestions (top outliers) and custom exclusions
        const exclusionItems = computed(() => {
          const items = [];
          const seen = new Set();

          // Add top outliers as suggestions
          if (topUsername.value) {
            const key = `username:${topUsername.value.value}`;
            seen.add(key);
            items.push({
              type: 'username',
              value: topUsername.value.value,
              count: topUsername.value.count,
              active: customExclusions.value.username.includes(topUsername.value.value),
              isCustom: false
            });
          }
          if (topPassword.value) {
            const key = `password:${topPassword.value.value}`;
            seen.add(key);
            items.push({
              type: 'password',
              value: topPassword.value.value,
              count: topPassword.value.count,
              active: customExclusions.value.password.includes(topPassword.value.value),
              isCustom: false
            });
          }
          if (topIP.value) {
            const key = `ip:${topIP.value.value}`;
            seen.add(key);
            items.push({
              type: 'ip',
              value: topIP.value.value,
              count: topIP.value.count,
              active: customExclusions.value.ip.includes(topIP.value.value),
              isCustom: false
            });
          }

          // Add custom exclusions that aren't already shown as suggestions
          for (const type of ['username', 'password', 'ip']) {
            for (const value of customExclusions.value[type]) {
              const key = `${type}:${value}`;
              if (!seen.has(key)) {
                items.push({
                  type,
                  value,
                  count: null,
                  active: true,
                  isCustom: true
                });
              }
            }
          }

          return items;
        });

        // Toggle exclusion on/off
        function toggleExclusion(item) {
          const { type, value } = item;
          const index = customExclusions.value[type].indexOf(value);
          if (index > -1) {
            // Remove from exclusions
            customExclusions.value[type].splice(index, 1);
          } else {
            // Add to exclusions
            customExclusions.value[type].push(value);
          }
        }

        // Pagination
        const totalPages = computed(() => Math.ceil(tableData.value.length / perPage) || 1);
        const paginatedData = computed(() => {
          const start = (currentPage.value - 1) * perPage;
          return tableData.value.slice(start, start + perPage);
        });

        // Password counts aggregation
        const passwordCounts = computed(() => {
          const data = tableData.value;
          const total = data.length;
          const map = new Map();

          data.forEach(a => {
            map.set(a.password, (map.get(a.password) || 0) + 1);
          });

          let results = [...map.entries()].map(([password, count]) => ({
            password,
            count,
            percentage: total > 0 ? ((count / total) * 100).toFixed(1) : 0
          }));

          // Sort
          results.sort((a, b) => {
            let valA = a[passwordSortColumn.value];
            let valB = b[passwordSortColumn.value];

            if (passwordSortColumn.value === 'password') {
              valA = String(valA).toLowerCase();
              valB = String(valB).toLowerCase();
            } else {
              valA = parseFloat(valA);
              valB = parseFloat(valB);
            }

            if (valA < valB) return passwordSortDirection.value === 'asc' ? -1 : 1;
            if (valA > valB) return passwordSortDirection.value === 'asc' ? 1 : -1;
            return 0;
          });

          return results;
        });

        const passwordTotalPages = computed(() => Math.ceil(passwordCounts.value.length / frequencyPerPage) || 1);
        const paginatedPasswordCounts = computed(() => {
          const start = (passwordPage.value - 1) * frequencyPerPage;
          return passwordCounts.value.slice(start, start + frequencyPerPage);
        });

        function togglePasswordSort(column) {
          if (passwordSortColumn.value === column) {
            passwordSortDirection.value = passwordSortDirection.value === 'asc' ? 'desc' : 'asc';
          } else {
            passwordSortColumn.value = column;
            passwordSortDirection.value = column === 'password' ? 'asc' : 'desc';
          }
          passwordPage.value = 1;
        }

        // Username counts aggregation
        const usernameCounts = computed(() => {
          const data = tableData.value;
          const total = data.length;
          const map = new Map();

          data.forEach(a => {
            map.set(a.username, (map.get(a.username) || 0) + 1);
          });

          let results = [...map.entries()].map(([username, count]) => ({
            username,
            count,
            percentage: total > 0 ? ((count / total) * 100).toFixed(1) : 0
          }));

          // Sort
          results.sort((a, b) => {
            let valA = a[usernameSortColumn.value];
            let valB = b[usernameSortColumn.value];

            if (usernameSortColumn.value === 'username') {
              valA = String(valA).toLowerCase();
              valB = String(valB).toLowerCase();
            } else {
              valA = parseFloat(valA);
              valB = parseFloat(valB);
            }

            if (valA < valB) return usernameSortDirection.value === 'asc' ? -1 : 1;
            if (valA > valB) return usernameSortDirection.value === 'asc' ? 1 : -1;
            return 0;
          });

          return results;
        });

        const usernameTotalPages = computed(() => Math.ceil(usernameCounts.value.length / frequencyPerPage) || 1);
        const paginatedUsernameCounts = computed(() => {
          const start = (usernamePage.value - 1) * frequencyPerPage;
          return usernameCounts.value.slice(start, start + frequencyPerPage);
        });

        function toggleUsernameSort(column) {
          if (usernameSortColumn.value === column) {
            usernameSortDirection.value = usernameSortDirection.value === 'asc' ? 'desc' : 'asc';
          } else {
            usernameSortColumn.value = column;
            usernameSortDirection.value = column === 'username' ? 'asc' : 'desc';
          }
          usernamePage.value = 1;
        }

        // Stats
        const totalAttempts = computed(() => filteredData.value.length);
        const uniqueIPs = computed(() => new Set(filteredData.value.map(a => a.ip)).size);
        const uniqueUsernames = computed(() => new Set(filteredData.value.map(a => a.username)).size);
        const last24Hours = computed(() => {
          const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000);
          return attempts.value.filter(a => new Date(a.created_at) >= cutoff).length;
        });

        // Chart colors - warm palette with cool accents (last is gray for "Other")
        const chartColors = [
          '#e8991a', // orange (primary)
          '#45b7d1', // teal
          '#f7dc6f', // soft yellow
          '#eb8f6a', // coral
          '#82e0aa', // mint green
          '#bb8fce', // lavender
          '#f1948a', // salmon
          '#6b7280'  // gray (for "Other")
        ];

        // Get top N items from frequency map, with "Other" for the rest
        function getTopNWithOther(map, n = 7) {
          const sorted = [...map.entries()].sort((a, b) => b[1] - a[1]);
          const top = sorted.slice(0, n);
          const rest = sorted.slice(n);

          if (rest.length > 0) {
            const otherSum = rest.reduce((sum, [, count]) => sum + count, 0);
            top.push(['Other', otherSum]);
          }

          return top;
        }

        // Group data by time period for timeline
        function getTimelineData(data, groupBy) {
          const groups = new Map();
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

          data.forEach(a => {
            const date = new Date(a.created_at);
            let sortKey, displayKey;

            switch (groupBy) {
              case 'hour':
                sortKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}`;
                displayKey = `${String(date.getHours()).padStart(2, '0')}:00`;
                break;
              case 'day':
                sortKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                displayKey = `${months[date.getMonth()]} ${date.getDate()}`;
                break;
              case 'week':
                const startOfWeek = new Date(date);
                startOfWeek.setDate(date.getDate() - date.getDay());
                sortKey = `${startOfWeek.getFullYear()}-${String(startOfWeek.getMonth() + 1).padStart(2, '0')}-${String(startOfWeek.getDate()).padStart(2, '0')}`;
                displayKey = `${months[startOfWeek.getMonth()]} ${startOfWeek.getDate()}`;
                break;
              case 'month':
                sortKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                displayKey = `${months[date.getMonth()]} ${date.getFullYear()}`;
                break;
            }

            if (!groups.has(sortKey)) {
              groups.set(sortKey, { display: displayKey, count: 0 });
            }
            groups.get(sortKey).count++;
          });

          // Sort by date and return with display labels
          const sorted = [...groups.entries()].sort((a, b) => a[0].localeCompare(b[0]));
          return sorted.map(([, v]) => [v.display, v.count]);
        }

        // Update timeline chart
        function updateTimelineChart() {
          const data = tableData.value;
          const timelineData = getTimelineData(data, timelineGroup.value);

          if (timelineChartInstance) timelineChartInstance.destroy();
          if (timelineChart.value) {
            timelineChartInstance = new Chart(timelineChart.value, {
              type: 'bar',
              data: {
                labels: timelineData.map(([k]) => k),
                datasets: [{
                  label: 'Attempts',
                  data: timelineData.map(([, v]) => v),
                  backgroundColor: 'rgba(232, 153, 26, 0.6)',
                  borderColor: '#e8991a',
                  borderWidth: 1,
                  borderRadius: 4,
                  hoverBackgroundColor: 'rgba(69, 183, 209, 0.8)'
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                  padding: 0
                },
                plugins: {
                  legend: {
                    display: false
                  }
                },
                scales: {
                  x: {
                    grid: {
                      color: 'rgba(232, 222, 222, 0.1)'
                    },
                    ticks: {
                      color: '#e8dede',
                      maxRotation: 45,
                      minRotation: 45,
                      font: { size: 9 },
                      padding: 2
                    }
                  },
                  y: {
                    grid: {
                      color: 'rgba(232, 222, 222, 0.1)',
                      drawTicks: false
                    },
                    ticks: {
                      color: '#e8dede',
                      font: { size: 9 },
                      padding: 2,
                      maxTicksLimit: 6
                    },
                    beginAtZero: true
                  }
                }
              }
            });
          }
        }

        // Create/update charts
        function updateCharts() {
          const data = tableData.value;

          // Update timeline
          updateTimelineChart();

          // Username frequency
          const usernameMap = new Map();
          data.forEach(a => usernameMap.set(a.username, (usernameMap.get(a.username) || 0) + 1));
          const topUsernames = getTopNWithOther(usernameMap);

          // Password frequency
          const passwordMap = new Map();
          data.forEach(a => passwordMap.set(a.password, (passwordMap.get(a.password) || 0) + 1));
          const topPasswords = getTopNWithOther(passwordMap);

          // Combo frequency
          const comboMap = new Map();
          data.forEach(a => {
            const key = `${a.username}:${a.password}`;
            comboMap.set(key, (comboMap.get(key) || 0) + 1);
          });
          const topCombos = getTopNWithOther(comboMap);

          // Chart options
          const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'right',
                labels: {
                  color: '#e8dede',
                  padding: 12,
                  font: { size: 11 }
                }
              }
            }
          };

          // Username chart
          if (usernameChartInstance) usernameChartInstance.destroy();
          if (usernameChart.value) {
            usernameChartInstance = new Chart(usernameChart.value, {
              type: 'doughnut',
              data: {
                labels: topUsernames.map(([k]) => k),
                datasets: [{
                  data: topUsernames.map(([, v]) => v),
                  backgroundColor: chartColors,
                  borderWidth: 0
                }]
              },
              options: chartOptions
            });
          }

          // Password chart
          if (passwordChartInstance) passwordChartInstance.destroy();
          if (passwordChart.value) {
            passwordChartInstance = new Chart(passwordChart.value, {
              type: 'doughnut',
              data: {
                labels: topPasswords.map(([k]) => k),
                datasets: [{
                  data: topPasswords.map(([, v]) => v),
                  backgroundColor: chartColors,
                  borderWidth: 0
                }]
              },
              options: chartOptions
            });
          }

          // Combo chart
          if (comboChartInstance) comboChartInstance.destroy();
          if (comboChart.value) {
            comboChartInstance = new Chart(comboChart.value, {
              type: 'doughnut',
              data: {
                labels: topCombos.map(([k]) => k),
                datasets: [{
                  data: topCombos.map(([, v]) => v),
                  backgroundColor: chartColors,
                  borderWidth: 0
                }]
              },
              options: chartOptions
            });
          }
        }

        // Format date
        function formatDate(dateStr) {
          return new Date(dateStr).toLocaleString();
        }

        // Reset page when filters change
        watch(filters, () => {
          currentPage.value = 1;
        }, { deep: true });

        // Update charts when filtered data changes
        watch(filteredData, () => {
          nextTick(updateCharts);
        });

        // Update charts when custom exclusions change
        watch(customExclusions, () => {
          nextTick(updateCharts);
        }, { deep: true });

        // Update timeline when grouping changes
        watch(timelineGroup, () => {
          nextTick(updateTimelineChart);
        });

        // Initial load
        onMounted(async () => {
          await fetchData();
          await nextTick();
          updateCharts();
        });

        return {
          attempts,
          loading,
          error,
          filters,
          filteredData,
          tableData,
          paginatedData,
          currentPage,
          totalPages,
          totalAttempts,
          uniqueIPs,
          uniqueUsernames,
          last24Hours,
          usernameChart,
          passwordChart,
          comboChart,
          timelineChart,
          timelineGroup,
          sortColumn,
          sortDirection,
          toggleSort,
          customExclusions,
          newExclusion,
          addExclusion,
          removeExclusion,
          exclusionItems,
          toggleExclusion,
          passwordCounts,
          paginatedPasswordCounts,
          passwordPage,
          passwordTotalPages,
          passwordSortColumn,
          passwordSortDirection,
          togglePasswordSort,
          usernameCounts,
          paginatedUsernameCounts,
          usernamePage,
          usernameTotalPages,
          usernameSortColumn,
          usernameSortDirection,
          toggleUsernameSort,
          formatDate
        };
      }
    }).mount('#app');
  </script>
</body>
</html>
